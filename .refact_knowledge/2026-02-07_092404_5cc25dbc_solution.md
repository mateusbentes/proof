---
id: "15014511-8635-4b7a-975e-2ca3515cf0a7"
title: "Fix ConversationalHome.js auth & profile flow bugs"
kind: code
created: 2026-02-07
updated: 2026-02-07
review_after: 2026-05-08
status: active
tags: ["auth", "bugfix", "conversations", "frontend", "onboarding", "planning", "state", "strategic"]
filenames: ["/home/mateus/proof/backend/package.json", "/home/mateus/proof/backend/src/routes/conversations.js", "/home/mateus/proof/backend/src/services/botService.js", "/home/mateus/proof/docker-compose.yml", "/home/mateus/proof/frontend/package.json", "/home/mateus/proof/frontend/src/pages/ConversationalHome.js", "backend/src/routes/conversations.js", "frontend/src/pages/ConversationalHome.js"]
---

# Solution
## 1) What’s actually broken right now (from the provided files)

You already have **one “chat”** implemented on the backend: **conversational authentication** (`backend/src/routes/conversations.js`). But the current web UI (`frontend/src/pages/ConversationalHome.js`) is **not correctly wired** to it and has multiple state/logic bugs that make onboarding unreliable or completely stuck.

### Critical bugs in `ConversationalHome.js`

1) **Registration sends wrong payload**
```js
await apiClient.post('/auth/register', {
  username: currentData.username,
  email: userInput,      // ❌ at this moment userInput is password
  password: userInput,   // ✅ password
});
```
This should be `email: currentData.email`.

2) **Stage `auth` can’t work**
`handleAuthFlow()` computes `currentQuestion` in a way that never becomes `0` or `1` initially, so it often does **nothing** and the user gets stuck. Also: it never calls `/conversations/message`, so backend auth conversation never progresses.

3) **Profile flow conditions are wrong (infinite loop / wrong step)**
```js
if (!currentData.avatarPrompt) { // ❌ used as “Get bio”
  setUserData({ ...currentData, bio: userInput });
  ...
}
```
This should check `!currentData.bio` for the bio step, then `!currentData.avatarPrompt` for avatar step.

4) **Password input masking is unreliable**
This line:
```js
type={stage === 'login' && userData.password ? 'password' : 'text'}
```
doesn’t switch to password at the right time. You want a dedicated “loginPassword step”, not guessing based on whether password is already stored.

---

## 2) Fix #1: Make onboarding robust by actually using `/conversations/*`

### Goal
After `/auth/register` returns `{ userId, sessionId }`, the frontend should:
- fetch/show the first prompt (if needed),
- send user responses to `POST /conversations/message`,
- when status becomes `completed`, then login and proceed to profile.

### Minimal, robust approach (recommended)
Use **a real step machine** (separate step counters) instead of trying to infer state from `userData` emptiness.

#### Patch highlights (web frontend)

**A) Fix register payload**
```diff
- email: userInput,
- password: userInput,
+ email: currentData.email,
+ password: userInput,
```

**B) Replace “auth” local Q&A with backend conversation calls**
Add state:
- `authSessionId`
- `authCompleted`
- `authLastBotMessage` (optional)

When user submits during `stage === 'auth'`:
- call `POST /conversations/message` with `{ sessionId, userMessage }`
- append user message + returned `botMessage`
- if `status === 'completed'`: login, store token/user, then proceed

Pseudo-implementation (drop-in concept):
```js
const handleAuthFlow = async (userInput) => {
  const { sessionId, email, password } = userData;
  addMessage('user', userInput);
  setLoading(true);

  try {
    const resp = await apiClient.post('/conversations/message', {
      sessionId,
      userMessage: userInput,
    });

    addMessage('bot', resp.data.botMessage);

    if (resp.data.status === 'completed') {
      // Now login (register endpoint does not return token)
      const loginResp = await apiClient.post('/auth/login', { email, password });
      setToken(loginResp.data.token);
      setUser(loginResp.data.user);

      setStage('profile');
      addMessage('bot', "✅ Verified! What's your display name?");
    }
  } catch (e) {
    addMessage('bot', `❌ Auth chat error: ${e.message}`);
  } finally {
    setLoading(false);
  }
};
```

**C) Fix profile step logic**
Use:
- displayName step
- bio step
- avatarPrompt step

Corrected logic:
```js
if (!currentData.displayName) { ... }
else if (!currentData.bio) { ... }
else if (!currentData.avatarPrompt) { ... } // final step -> save + generate
```

**Corner cases handled**
- If `sessionId` is missing (backend changed): call `POST /conversations/start` with `userId`, store returned `sessionId`.
- If `/conversations/message` returns “Conversation already completed”: skip to login/profile.
- If Rasa is down: backend already falls back (your code prints warning and still works).

---

## 3) Implement “social chat” (DMs / group chat) across backend + web + mobile

Right now, the only chat is onboarding auth. If you want **user-to-user chat**, you need a separate module to avoid conflicts with the existing `conversations` tables.

### 3.1 Database schema (Postgres)

Create new tables (names avoid collision with `conversations` used by auth):

- `chat_threads` (a DM or group)
- `chat_thread_participants`
- `chat_messages`

Example migration SQL (robust baseline):
```sql
CREATE TABLE IF NOT EXISTS chat_threads (
  id uuid PRIMARY KEY,
  thread_type text NOT NULL CHECK (thread_type IN ('dm', 'group')),
  title text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS chat_thread_participants (
  thread_id uuid NOT NULL REFERENCES chat_threads(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role text NOT NULL DEFAULT 'member',
  joined_at timestamptz NOT NULL DEFAULT now(),
  last_read_at timestamptz,
  PRIMARY KEY (thread_id, user_id)
);

CREATE TABLE IF NOT EXISTS chat_messages (
  id uuid PRIMARY KEY,
  thread_id uuid NOT NULL REFERENCES chat_threads(id) ON DELETE CASCADE,
  sender_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  client_message_id uuid, -- for de-duplication on retries
  content text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  edited_at timestamptz,
  deleted_at timestamptz,
  UNIQUE (thread_id, sender_id, client_message_id)
);

CREATE INDEX IF NOT EXISTS idx_chat_messages_thread_time
  ON chat_messages(thread_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_chat_participants_user
  ON chat_thread_participants(user_id);
```

**Corner cases covered**
- `client_message_id` lets mobile/web retry safely without duplicate messages (at-least-once delivery).
- soft-delete supported via `deleted_at`.

### 3.2 Backend REST API (minimum viable)

Add `backend/src/routes/chat.js`:

- `GET /chat/threads` → list threads for user (with last message + unread count)
- `POST /chat/threads` → create DM/group
- `GET /chat/threads/:threadId/messages?before=&limit=` → pagination
- `POST /chat/threads/:threadId/messages` → send message (REST fallback)
- `POST /chat/threads/:threadId/read` → mark read

**All routes must require `verifyToken`.** Also verify the user is a participant for every thread.

### 3.3 Real-time transport (recommended): WebSocket via Socket.IO

Add dependencies:
- backend: `socket.io`
- frontend/mobile: `socket.io-client`

Backend setup (conceptually):
- create HTTP server from Express
- attach `io = new Server(server, { cors: ... })`
- authenticate socket using JWT
- `socket.join(`user:${userId}`)` for direct targeting
- `socket.on('message:send', ...)` insert into DB then emit `message:new` to all participants

**Corner cases**
- reconnect: client re-joins thread rooms
- ack: server returns `{messageId, createdAt}` so UI can mark “sent”
- rate limit: reuse your existing `express-rate-limit` for REST; for sockets implement simple per-socket throttling

### Alternative (if you don’t want sockets yet)
1) **Polling**: web/mobile polls `GET /messages` every N seconds.
2) **SSE** (Server-Sent Events): simpler than sockets for one-way “new message” stream, but harder on mobile backgrounding.

---

## 4) Mobile apps implementation (recommended path)

### Option A (recommended): Expo + React Native
Create `/mobile` using Expo, reuse the same API patterns as web:
- auth store (Zustand)
- `apiClient` with `EXPO_PUBLIC_API_URL`
- chat screens:
  - Threads list
  - Chat thread (FlatList inverted)
  - Compose box + optimistic sending using `client_message_id`

**Critical corner case for mobile dev**
“localhost” does not work on real devices.
- Android emulator: use `10.0.2.2`
- iOS simulator: `localhost` usually works
- physical phone: use your LAN IP (e.g. `http://192.168.1.50:3001/api`)

### Option B: Capacitor (wrap your existing React frontend)
Fastest to ship a “mobile app-like” experience:
- keep current React app
- add Capacitor
- chat via the same REST/socket endpoints
Tradeoff: UX not as native; still very practical.

### Option C: Flutter
If your team prefers Dart/Flutter, still use the same backend. More work if you want to share UI logic with web.

---

## 5) If the initial solution doesn’t work — alternative ways to solve it

### Alternative 1: No real-time layer yet (REST-only chat)
- Implement only:
  - create thread
  - send message
  - list messages
- Add polling on clients
This avoids socket infrastructure and is easiest to debug.

### Alternative 2: Use existing “conversations” pattern but rename & expand
If you want to reuse the *idea* of `conversations.js`, do **not** reuse the same tables. Instead:
- keep `/conversations/*` strictly for onboarding verification
- add `/chat/*` for social chat
This avoids breaking onboarding and keeps responsibilities clean.

---

## Summary of “do this now” (highest impact)
1) **Fix onboarding frontend bugs** (register payload, auth flow wired to `/conversations/message`, profile steps).
2) Add **new chat tables** (`chat_*`) + `/chat` routes.
3) Add Socket.IO for real-time (or polling as fallback).
4) Build mobile app using Expo (or Capacitor if you want fastest path).

If you paste the contents of `MOBILE_APPS.md` and your current backend `auth` routes (especially `/auth/register` response behavior), I can give you an exact, file-by-file patch plan that matches your repo conventions (including migrations wiring and the exact Express entrypoint changes needed for Socket.IO).